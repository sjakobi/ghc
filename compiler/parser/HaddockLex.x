{
-- TODO: Update Note [Warnings in code generated by Alex] in
-- compiler/parser/Lexer.x and the warnings prescribed in it.
{-# OPTIONS_GHC -fno-warn-unused-matches #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}

{-# OPTIONS_GHC -funbox-strict-fields #-}

module HaddockLex (lexHsDoc) where

import GhcPrelude

import FastString
import HsDoc
import Lexer
import Module
import SrcLoc
import StringBuffer
import RdrName
import qualified EnumSet

import Data.Maybe

import GHC.LanguageExtensions.Type (Extension(MagicHash))
}

%wrapper "posn"

-- The character sets marked "TODO" are mostly overly inclusive
-- and should be defined more precisely once alex has better
-- support for unicode character sets (see
-- https://github.com/simonmar/alex/issues/126).
$special   = [\(\)\,\;\[\]\`\{\}]
$asciisymbol = [\!\#\$\%\&\*\+\.\/\<\=\>\?\@\\\^\|\-\~\:]
$asciidigit = 0-9
$digit = $asciidigit                             -- TODO
$asciilower = [a-z \_]
$asciiupper = A-Z
$asciialpha = [$asciilower $asciiupper]
$interesting = $printable # [$white $special]
$alpha = $interesting # [$digit $asciisymbol \'] -- TODO
$upper = $alpha # $asciilower                    -- TODO
$symbol = $interesting # [$digit $asciialpha \'] -- TODO
$idchar = [$alpha $digit \']
$delim = [\'\`]

@id = ($alpha $idchar* | $symbol+) \#*
@modname = $upper $idchar*
@qualid = (@modname \.)* @id

:-
  $delim @qualid $delim { getIdentifier }
  [. \n] ;

{
-- | Shave off delimiters, compute offsets.
getIdentifier :: AlexPosn -> String -> (Int, String, Int)
getIdentifier (AlexPn off0 _ _) s0 =
    (off1, s1, off1 + length s1)
  where
    off1 = succ off0
    s1 = init (tail s0)

-- | Lex identifiers from a docstring.
lexHsDoc :: P RdrName      -- ^ A precise identifier parser
         -> String         -- ^ A docstring
         -> HsDoc RdrName
lexHsDoc identParser s =
    HsDoc (mkHsDocString s) (mapMaybe maybeDocIdentifier plausibleIdents)
  where
    maybeDocIdentifier :: (Int, String, Int) -> Maybe (HsDocIdentifier RdrName)
    maybeDocIdentifier (ix0, pid, ix1) =
      HsDocIdentifier (HsDocIdentifierSpan ix0 ix1) . (: [])
        <$> validateIdentWith identParser pid

    plausibleIdents :: [(Int, String, Int)]
    plausibleIdents = alexScanTokens s

validateIdentWith :: P RdrName -> String -> Maybe RdrName
validateIdentWith identParser str0 =
  let pflags = ParserFlags EnumSet.empty (EnumSet.fromList [MagicHash]) (stringToUnitId "") 0
      buffer = stringToStringBuffer str0
      realSrcLc = mkRealSrcLoc (mkFastString "") 0 0
      pstate = mkPStatePure pflags buffer realSrcLc
  in case unP identParser pstate of
    POk _ name -> Just name
    _ -> Nothing
}
